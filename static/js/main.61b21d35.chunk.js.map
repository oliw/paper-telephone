{"version":3,"sources":["models/entry.js","models/paper.js","game.js","draw.js","write.js","board.js","App.js","serviceWorker.js","index.js"],"names":["Entry","number","this","writing","drawing","author","entryFilledIn","entry","paperHasCompletedEntry","paper","entryNumber","entries","length","Paper","player","numEntries","Array","fill","i","Game","name","setup","ctx","numPlayers","numberOfRounds","papers","playerIdsToPaperIdx","currentSubmissionMethod","turn","onBegin","G","onEnd","currentHand","newHand","Object","keys","forEach","playerId","previousIdx","nextIdx","endIf","every","activePlayers","all","moveLimit","stages","submit","moves","SubmitWriting","playerID","paperIndex","SubmitDrawing","minPlayers","maxPlayers","Drawer","props","onImageSelected","previousPhrase","videoEl","useRef","canvasEl","useState","imageData","setImageData","useEffect","navigator","mediaDevices","getUserMedia","video","then","stream","current","srcObject","play","ref","autoPlay","width","height","onClick","getContext","drawImage","toDataURL","Writer","onPhraseChosen","previousDrawingUri","React","setWriting","src","alt","type","value","onChange","event","target","Board","_","gameover","currentPageIdx","latestEnt","slice","reverse","find","latestDrawingUri","latestWriting","drawingUri","importedGames","game","board","App","gameServer","lobbyServer","gameComponents","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.61b21d35.chunk.js","sourcesContent":["export class Entry {\n  constructor(number) {\n    this.number = number;\n    this.writing = null;\n    this.drawing = null;\n    this.author = null;\n  }\n}\n\nexport function entryFilledIn(entry) {\n  return entry.drawing != null || entry.writing != null;\n}\n\nexport function entryNotFilledIn(entry) {\n  return !entryFilledIn(entry);\n}\n","import { Entry, entryFilledIn, entryNotFilledIn } from \"./entry\";\n\nexport function paperHasCompletedEntry(paper, entryNumber) {\n  if (entryNumber < 0 || entryNumber >= paper.entries.length) {\n    return false;\n  }\n  return entryFilledIn(paper.entries[entryNumber]);\n}\n\nexport function unfilledEntry(paper) {\n  return paper.entries.find(entry => entryNotFilledIn(entry));\n}\n\nexport function latestEntry(paper) {\n  return paper.entries\n    .slice()\n    .reverse()\n    .find(entry => entryFilledIn(entry));\n}\n\nexport class Paper {\n  constructor(player, numEntries) {\n    this.player = player;\n    this.entries = Array(numEntries).fill(null);\n    for (let i = 0; i < numEntries; i++) {\n      this.entries[i] = new Entry(i);\n    }\n  }\n}\n","import { Paper, paperHasCompletedEntry } from \"./models/paper\";\n\n// TURN\nfunction OnBegin(G, ctx) {\n  G.currentSubmissionMethod = ctx.turn % 2 === 0 ? \"draw\" : \"write\";\n}\n\n// TURN\nfunction OnEnd(G, ctx) {\n  // Exchange Papers\n  const { numPlayers } = ctx;\n  const currentHand = G.playerIdsToPaperIdx;\n  const newHand = {};\n  Object.keys(currentHand).forEach(playerId => {\n    const previousIdx = currentHand[playerId];\n    const nextIdx = (numPlayers + previousIdx - 1) % numPlayers;\n    newHand[playerId] = nextIdx;\n  });\n  return {\n    ...G,\n    playerIdsToPaperIdx: newHand\n  };\n}\n\n// MOVE\nfunction SubmitWriting(G, ctx, writing, ...args) {\n  const { playerID, turn } = ctx;\n  const paperIndex = G.playerIdsToPaperIdx[playerID];\n  G.papers[paperIndex].entries[turn - 1] = {\n    ...G.papers[paperIndex].entries[turn - 1],\n    writing,\n    author: playerID\n  };\n}\n\n// MOVE\nfunction SubmitDrawing(G, ctx, drawing) {\n  const { playerID, turn } = ctx;\n  const paperIndex = G.playerIdsToPaperIdx[playerID];\n  G.papers[paperIndex].entries[turn - 1] = {\n    ...G.papers[paperIndex].entries[turn - 1],\n    drawing,\n    author: playerID\n  };\n}\n\nfunction isTurnFinished(G, ctx) {\n  // The turn is finished when every paper has a complete\n  // entry for the currentEntry\n  const { turn } = ctx;\n  return G.papers.every(paper => paperHasCompletedEntry(paper, turn - 1));\n}\n\nfunction isGameFinished(G) {\n  // The game is finished when there is a filled in entry for the Nth round\n  const { numberOfRounds, papers } = G;\n  const isFinished = papers.every(paper =>\n    paperHasCompletedEntry(paper, numberOfRounds - 1)\n  );\n\n  if (isFinished) {\n    return {};\n  }\n\n  // Not finished\n  return null;\n}\n\nexport const Game = {\n  name: \"paper-telephone\",\n\n  setup: ctx => {\n    const numPlayers = ctx.numPlayers;\n    const numberOfRounds = numPlayers * 2;\n    const papers = Array(numPlayers);\n    const playerIdsToPaperIdx = {};\n    for (let i = 0; i < numPlayers; i++) {\n      papers[i] = new Paper(i, numberOfRounds);\n      playerIdsToPaperIdx[`${i}`] = i;\n    }\n\n    return {\n      papers: papers,\n      numberOfRounds: numberOfRounds,\n      currentSubmissionMethod: null,\n      playerIdsToPaperIdx: playerIdsToPaperIdx\n    };\n  },\n\n  turn: {\n    onBegin: OnBegin,\n    onEnd: OnEnd,\n    endIf: isTurnFinished,\n    activePlayers: { all: \"submit\", moveLimit: 1 },\n    stages: {\n      submit: {\n        moves: {\n          SubmitWriting,\n          SubmitDrawing\n        }\n      }\n    }\n  },\n\n  moves: {},\n\n  endIf: isGameFinished,\n\n  minPlayers: 2,\n  maxPlayers: 10\n};\n\nexport default Game;\n","import React, { useState, useEffect, useRef } from \"react\";\n\nfunction Drawer(props) {\n  const { onImageSelected, previousPhrase } = props;\n\n  const videoEl = useRef(null);\n  const canvasEl = useRef(null);\n\n  const [imageData, setImageData] = useState(null);\n\n  useEffect(() => {\n    if (!videoEl) {\n      return;\n    }\n    navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {\n      let video = videoEl.current;\n      video.srcObject = stream;\n      video.play();\n    });\n  }, [videoEl]);\n\n  const handleTakePicClick = () => {\n    var ctx = canvasEl.current.getContext(\"2d\");\n    ctx.drawImage(\n      videoEl.current,\n      0,\n      0,\n      canvasEl.current.width,\n      canvasEl.current.height\n    );\n    setImageData(canvasEl.current.toDataURL(\"image/jpeg\"));\n  };\n\n  const handleClick = () => {\n    if (onImageSelected) {\n      onImageSelected(imageData);\n    }\n  };\n\n  return (\n    <div>\n      <p>Time to draw!</p>\n      <p>Can you draw this phrase?</p>\n      <p>{previousPhrase}</p>\n      <video ref={videoEl} autoPlay={true}></video>\n      <canvas ref={canvasEl} width={480} height={640}></canvas>\n      <button onClick={handleTakePicClick}>Take Pic</button>\n      <button onClick={handleClick}>Submit</button>\n    </div>\n  );\n}\n\nexport default Drawer;\n","import React from \"react\";\n\nfunction Writer(props) {\n  const { onPhraseChosen, previousDrawingUri } = props;\n\n  const [writing, setWriting] = React.useState(\"\");\n\n  const handleWritingChange = event => {\n    setWriting(event.target.value);\n  };\n\n  const handleClick = () => {\n    onPhraseChosen(writing);\n  };\n\n  return (\n    <div>\n      <p>Time to write!</p>\n      {previousDrawingUri && <img src={previousDrawingUri} alt=\"Foo\" />}\n      <input type=\"text\" value={writing} onChange={handleWritingChange} />\n      <button onClick={handleClick}>Submit</button>\n    </div>\n  );\n}\n\nexport default Writer;\n","import React from \"react\";\nimport Drawer from \"./draw\";\nimport Writer from \"./write\";\nimport { latestEntry } from \"./models/paper\";\n\nfunction Board(props) {\n  const { moves, _, G, ctx, playerID } = props;\n\n  const handleSubmitWriting = writing => {\n    moves.SubmitWriting(writing);\n  };\n\n  const handleSubmitDrawing = drawingUri => {\n    moves.SubmitDrawing(drawingUri);\n  };\n\n  if (ctx.gameover) {\n    return (\n      <div>\n        <h1>Game over!</h1>\n      </div>\n    );\n  }\n\n  const currentPageIdx = G.playerIdsToPaperIdx[playerID];\n  const currentPage = G.papers[currentPageIdx];\n  const latestEnt = latestEntry(currentPage);\n\n  let latestDrawingUri = null;\n  let latestWriting = null;\n\n  if (latestEnt && G.currentSubmissionMethod === \"write\") {\n    latestDrawingUri = latestEnt.drawing;\n  }\n\n  if (latestEnt && G.currentSubmissionMethod === \"draw\") {\n    latestWriting = latestEnt.writing;\n  }\n\n  return (\n    <div>\n      <h1>Welcome to Telephone!</h1>\n      <p>\n        The current turn is: {ctx.turn}, which means its time to:{\" \"}\n        {G.currentSubmissionMethod}\n      </p>\n      <p>\n        There are {ctx.numPlayers} players. You are player {playerID}\n      </p>\n      {G.currentSubmissionMethod === \"write\" && ctx.activePlayers[playerID] && (\n        <Writer\n          onPhraseChosen={handleSubmitWriting}\n          previousDrawingUri={latestDrawingUri}\n        />\n      )}\n      {G.currentSubmissionMethod === \"draw\" && ctx.activePlayers[playerID] && (\n        <Drawer\n          onImageSelected={handleSubmitDrawing}\n          previousPhrase={latestWriting}\n        />\n      )}\n      {!ctx.activePlayers[playerID] && (\n        <p>Waiting for others to finish their move</p>\n      )}\n    </div>\n  );\n}\n\nexport default Board;\n","import React from \"react\";\nimport Game from \"./game\";\nimport Board from \"./board\";\nimport { Lobby } from \"boardgame.io/react\";\n\nconst importedGames = [\n  {\n    game: Game,\n    board: Board\n  }\n];\n\nconst App = () => (\n  <div>\n    <Lobby\n      gameServer={`http://paper-gamer.herokuapp.com`}\n      lobbyServer={`http://paper-gamer.herokuapp.com`}\n      gameComponents={importedGames}\n    />\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}